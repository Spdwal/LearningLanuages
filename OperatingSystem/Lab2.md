# Lab Requirements

做完所有的练习，并且完成起码一个challenge。

# Part 1: Physical Page Management

## Exercise 1

在kern/pmap.c中，完成如下代码：

```c
boot_alloc()
mem_init()
page_init()
page_alloc()
page_free()
```

```c
static void *
boot_alloc(uint32_t n)
{
    // 虚拟地址中下一块可用的内存
    // 它是一个静态变量，所以需要不断的更新。
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
    //  end 是链接器产生的一个魔法symbol，它指向了bss段的末尾。
    //  bss前面是data段，后面是空白。这个指针指向的空间，链接器没有放入任何kernel带代码或者全局变量。
    // 所以可以任意的使用。
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
    // 第一次调用这个函数的时候，他是静态初始化状态，为0，所以我们在此为其赋值。
	if (!nextfree) {
		extern char end[];
        // 向上对齐最近的PGSIZE。
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
    // 分配空间，用PGSIZE作为对齐。
	char * new_next_free = ROUNDUP((char *)n + nextfree, PGSIZE);
    // 如果new_next_free < nextfree) 分配失败。
    if(new_next_free < nextfree){
        panic("Boot alloc bad.\n");
    }
    //超过地址空间。
    if(new_next_free >= 0x400000){
        panic("The boot alloc extendx 4MB.\n");
    }
    
    // 保存需要返回的值
    void* ret_adress = (void*) nextfree;
    // 更新值。
    nextfree = new_next_free;
	return ret_adress;
}
```

```c
/*******************************************************************************
	struct PageInfo {
		// Next page on the free list.
		struct PageInfo *pp_link;

		// pp_ref is the count of pointers (usually in page table entries)
		// to this page, for pages allocated using page_alloc.
		// Pages allocated at boot time using pmap.c's
		// boot_alloc do not have valid reference count fields.

		uint16_t pp_ref;
	};
*******************************************************************************/

// --------------------------------------------------------------
// Tracking of physical pages.
// The 'pages' array has one 'struct PageInfo' entry per physical page.
// Pages are reference counted, and free pages are kept on a linked list.
// --------------------------------------------------------------

//
// Initialize page structure and memory free list.
// After this is done, NEVER use boot_alloc again.  ONLY use the page
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
	// The example code here marks all physical pages as free.
	// However this is not truly the case.  What memory is free?
	//  1) Mark physical page 0 as in use.
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free.
    //      [1, npages_basemem]这一段的内存是free的。
    //     紧跟在后的是[IOPHTSMEM, EXTPHTSMEM]这一段内存，他们也不可以被alloc
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated.
	//  4) Then extended memory [EXTPHYSMEM, ...).
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
    size_t i;
	page_free_list = NULL;
	int num_alloc = PADDR(boot_alloc(0)) / PGSIZE;
	int num_iohole = 96;
	for(i = 0; i < npages; i++){
		if(i == 0){
			pages[i].pp_ref = 1;
		}
		else if(i >= npages_basemem && i < npages_basemem + num_iohole + num_alloc){
			pages[i].pp_ref = 1;
		}else{
			pages[i].pp_ref = 0;
			pages[i].pp_link = page_free_list;
			page_free_list = &pages[i];
		}
	}
	// size_t i;
    // // 第一个page是被使用的；
    // 此代码错误，没有初始化page_free_list！！！！！！
    // 所以page_free_list的尾部没有指向NULL！！！！！！
    // 所以左后出错了！！！！
    // pages[0].pp_ref = 1;
	// for (i = 1; i < npages_basemem; i++) {
	// 	pages[i].pp_ref = 0;
	// 	pages[i].pp_link = page_free_list;
    //    // 因为是空闲页，所以将它送入pages_free_list链表。
    //    // 头插法进入链表
	//	page_free_list = &pages[i];
	//}
    // // 返回可分配空间的第一个位置，计算出的它物理地址，然后除以PGSIZE,得出extmem区域中已经被占用的页数。
 	// int num_alloc = ((uint_32t)boot_alloc(0) - KERNBASE) / PGSIZE;
    //  // iohole区域被占用的页数。
    // int iohole = (EXTPHYSMEM - IOPHYMEM) / PGSIZE;
    // // iohole 不能被alloc
    // for(; i < npages_basemem + num_alloc + iohole; ++i){
    //     pages[i].pp_ref = 1;
    // }
    // for(i = npages_basemem + num_alloc + iohole; i < npages; ++i){
    //     pages[i].pp_ref = 0;
    //     pages[i].pp_link = page_free_list;
    //     page_free_list = &pages[i];
    // }
}
```

```c
// Allocates a physical page.  If (alloc_flags & ALLOC_ZERO), fills the entire
// returned physical page with '\0' bytes.  Does NOT increment the reference
// count of the page - the caller must do these if necessary (either explicitly
// or via page_insert).
//
// Be sure to set the pp_link field of the allocated page to NULL so
// page_free can check for double-free bugs.
//
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
	// Fill this function in
	// 返回值。
	struct Pageinfo* result;
	//  如果没有free空间了。打印信息，返回NULL
	if(page_free_list == NULL){
		cprintf("No Page Free.\n");
		return NULL;
	}
	// 取链表中第一个为result
	result = page_free_list;
    // 将头从链表中弹出。
	page_free_list = result->pp_link;
    // 将头彻底语链表分离。
	result->pp_link = NULL;
	
    // 按照注释所说，如果传入了一个ALLOC_ZERO flag，那么将整个页初始化为0
	if(alloc_flags & ALLOC_ZERO){
		memset(page2kva(result), 0, PGSIZE);
	}
	return result;
}

```

```c
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if(pp->pp_ref != 0){
		panic("Can't Free: the page is reference by someone.\n");
	}
	if(pp->pp_link != NULL){
		panic("Can;t Free. the page is in the page free list.\n");
	}
	// 将pp添加在page_free_List的头部
	pp->pp_link = page_free_list;
	page_free_list = pp;
}

```

# Part 2: Virtual Memory

## Exercise 2

阅读Intel 80386 Reference Manual的第五章和第六章，重点是页转换和page-based protection。

文档写的是真的晦涩，难看的要命。

在x86中，一个虚拟地址是有一个段选择子和一个段offset组成的。一个虚拟地址转换成物理地址需要经过段转换和页转换。

在boot/boot.s中，我们吧GDT加载进了内存，并且通过将段地址设置为0~0xffffffff来关闭了段转换，所以现在selector就没有用了，线性地址就等于虚拟地址的偏移。在Lab1中，我们加载了一个简单的页表，然后内核可以运行在0xf0100000中，这个页表只映射了4MB的内存。我们将会使它映射虚拟地址0xf0000000的头256MB，并且映射其他的虚拟地址空间。

## Exercise 3

Gdb只可以查看QEMU的虚拟地址，但是如果我们可以查看物理地址的话，会更有帮助，qemu里有一个内置的监控器，官网是可以使用c-a c可以切换到这个监控器，但是在我的虚拟机上。。。并没有办法使用，此实验跳过。

当代码在cpu上训醒开始，我们就在保护模式下运行，我们没有办法直接使用线性地址或者是物理地址，所有的内存都被解释成一个虚拟地址，并且被MMU所翻译，所以C指针指向的，其实是一个虚拟地址。

JOS内核通常需要把地址按照以一种模糊的值或者整数值的形式来操纵，而不是直接解析引用，比如物理内存分配器。有时使用虚拟地址，有时使用物理地址。为了能够帮助我们记录代码，JOS源文件中的地址被区分为两种情况：

　　uintptr_t -- 表示虚拟地址

　　physaddr_t -- 表示物理地址

这两种类型其实都是32位的整型数(uint32_t)，所以如果你把一个类型的变量的值赋给另一个类型变量，编译器不会报错。但是由于他们都是整型数，所以如果你打算解引用(deference)他们，编译器会报错。

JOS内核可以先对uintptr_t类型的值进行强制类型转换，然后再解析引用。但是对于physaddr_t的值，我们不能这么做，因为内核是需要MMU（内存管理单元）来首先对你输入的地址进行转化的，_如果你对physaddr_t进行强制类型装换再解引用，最终你得到的你要访问的地址，可能不是你要找的真实物理地址。_

在之后的实验中，你将会经常遇到一种情况，多个不同的虚拟地址被同时映射到相同的物理页上面。这时我们需要记录一下每一个物理页上存在着多少不同的虚拟地址来引用它，这个值存放在这个物理页的PageInfo结构体的pp_ref成员变量中。当这个值变为0时，这个物理页才可以被释放。通常来说，任意一个物理页p的pp_ref值等于它在所有的页表项中，被位于虚拟地址UTOP之下的虚拟页所映射的次数（UTOP之上的地址范围在启动的时候已经被映射完成了，之后不会被改动）。

假设下述JOS内核代码是正确的，那么变量x应该是uintptr_t类型呢，还是physaddr_t呢？　　　

```c
mystery_t x;
char* value = return_a_pointer();
*value = 10;
x = (mystery_t) value;
```

这里使用了*操作符，所以变量x应该是uintptr_t类型。

## Exercise 4

完成kern/pmap.c中的一下代码：

Pgdir_walk();

Boot_map_region()

page_lookup()

page_remove()

page_insert()

```c
// Given 'pgdir', a pointer to a page directory, pgdir_walk returns
// a pointer to the page table entry (PTE) for linear address 'va'.
// This requires walking the two-level page table structure.
//
// The relevant page table page might not exist yet.
// If this is true, and create == false, then pgdir_walk returns NULL.
// Otherwise, pgdir_walk allocates a new page table page with page_alloc.
//    - If the allocation fails, pgdir_walk returns NULL.
//    - Otherwise, the new page's reference count is incremented,
//	the page is cleared,
//	and pgdir_walk returns a pointer into the new page table page.
//
// Hint 1: you can turn a PageInfo * into the physical address of the
// page it refers to with page2pa() from kern/pmap.h.
//
// Hint 2: the x86 MMU checks permission bits in both the page directory
// and the page table, so it's safe to leave permissions in the page
// directory more permissive than strictly necessary.
//
// Hint 3: look at inc/mmu.h for useful macros that manipulate page
// table and page directory entries.
//
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	// Fill this function in
	pde_t *pde;
	pte_t *pte;
	
    // 找到pde的地址。
	pde = &pgdir[PDX(va)];
	if(*pde & PTE_P){
		pte = (pte_t*)KADDR(PTE_ADDR(*pde));
     //如果不存在，则创建一个页
	}else{
        // flag，如果不让创建的话，就直接返回NULL。
		if(!create){
			return NULL;
		}
        // 创建一个页表,传入ALLOC_ZERO，省去memset0的调用。
        struct pageInfo* page_info = page_alloc(ALLOC_ZERO);
        // 创建不成功， 返回NULL
        if(page_info == 0){
            return NULL;
        }
		// reference++
		page_info->pp_ref++;
        
		*pde = page2pa(page_info) | PTE_P | PTE_W | PTE_U;
        // pde物理地址地址转化为kern虚拟地址
        pte = KADDR(PTE_ADDR(*pde));
	}
	return &pte[PTX(va)];
}
```

```c
//
// Map [va, va+size) of virtual address space to physical [pa, pa+size)
// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and
// va and pa are both page-aligned.
// Use permission bits perm|PTE_P for the entries.
//
// This function is only intended to set up the ``static'' mappings
// above UTOP. As such, it should *not* change the pp_ref field on the
// mapped pages.
//
// Hint: the TA solution uses pgdir_walk
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	int i;
	pte_t *entry = NULL;
    // 一个page 一个page的映射，没有什么好说的。
	for(int i = 0; i < size; i += PGSIZE){
        entry = pgdir_walk(pgdir, (void*)va, 1);
        
        *entry = (pa | perm | PTE_P);
        
        pa += PGSIZE;
        va += PGSIZE;
	}
}

```

```c
//
// Map the physical page 'pp' at virtual address 'va'.
// The permissions (the low 12 bits) of the page table entry
// should be set to 'perm|PTE_P'.
//
// Requirements
//   - If there is already a page mapped at 'va', it should be page_remove()d.
//   - If necessary, on demand, a page table should be allocated and inserted
//     into 'pgdir'.
//   - pp->pp_ref should be incremented if the insertion succeeds.
//   - The TLB must be invalidated if a page was formerly present at 'va'.
//
// Corner-case hint: Make sure to consider what happens when the same
// pp is re-inserted at the same virtual address in the same pgdir.
// However, try not to distinguish this case in your code, as this
// frequently leads to subtle bugs; there's an elegant way to handle
// everything in one code path.
//
// RETURNS:
//   0 on success
//   -E_NO_MEM, if page table couldn't be allocated
//
// Hint: The TA solution is implemented using pgdir_walk, page_remove,
// and page2pa.
//
int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
	// Fill this function in
    pte_t* entry = 0;
	entry = pgdir_walk(pgdir, (void*)va, 1);
    // 如果分配不成功
	if(entry == NULL){
		return -E_NO_MEM;
	}
	// reference ++
	pp->pp_ref++;
    // 如果已经存在，那么将这个地址上的page给初始化掉。
	if(*entry | PTE_P){
		page_remove(pgidr, va);
	}
	
    // 设置PTE
	*makentry = page2pa(pp) | perm | PTE_P;
	// 设置PDE
	pgdir[PDX(va)] |= perm;
	return 0;
}
```

```c

// Return the page mapped at virtual address 'va'.
// If pte_store is not zero, then we store in it the address
// of the pte for this page.  This is used by page_remove and
// can be used to verify page permissions for syscall arguments,
// but should not be used by most callers.
//
// Return NULL if there is no page mapped at va.
//
// Hint: the TA solution uses pgdir_walk and pa2page.
//
struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
	// Fill this function in
	pte_t* entry = NULL;
	struct PageInfo* page_info = NULL
    // 寻找pte，但是如果没有，并不创建它。
	entry = pgdir_walk(pgdir, (void*)va, 0);
	if(entry == NULL){
		return NULL;
	}
	// 如果page不存在的话，return NULL
	if(!(*entry & PTE_P)){
		return NULL;
	}
	
    //转换页信息
	page_info = pa2page(PTE_ADDR(*entry));
	
	if(pte_store != NULL){
		*ptr_store = entry;
	}
	return page_info;
}

```

```c

// Unmaps the physical page at virtual address 'va'.
// If there is no physical page at that address, silently does nothing.
//
// Details:
//   - The ref count on the physical page should decrement.
//   - The physical page should be freed if the refcount reaches 0.
//   - The pg table entry corresponding to 'va' should be set to 0.
//     (if such a PTE exists)
//   - The TLB must be invalidated if you remove an entry from
//     the page table.
//
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pde_t *pgdir, void *va)
{
	// Fill this function in
	pte_t* entry = NULL;
    // 找这个page，并且将
	struct PageInfo *page = page_lookup(pgdir, va, &entry);
	if(page == null) return;
	
	// page->pp_ref--, 如果是
	page_decref(page);
    // 底层使用汇编清除va地址上的tlb缓存，
	tlb_invalidate(pgdir, va);
	*entry = NULL;
}

```

# Part 3: Kernel Adress Space

Jos将32位线性地址分成两部分，其中用户环境占据低地址的那部分，内核负责维护和控制高地址的部分。他们的分界线被定义为inc/memlayout.h的ULIM

```c
#define NPTENTRITS 1024                       // 每一个page table里有几个entry
#define PTSIZE (PGSIZE*NPTENTRIES)            // page table size，一个pagetable hold的内存
#define KSTACKTOP KERNBASE     
#define MMIOLIM (KSTACKTOP - PTSIZE)          // 
#define MMILBASE (MMIOLIM - PTSIZE)
#define ULIM (MMIOBASE)
```

```c

/*
 * Virtual memory map:                                Permissions
 *                                                    kernel/user
 *
 *    4 Gig -------->  +------------------------------+
 *                     |                              | RW/--
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     :              .               :
 *                     :              .               :
 *                     :              .               :
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--
 *                     |                              | RW/--
 *                     |   Remapped Physical Memory   | RW/--
 *                     |                              | RW/--
 *    KERNBASE, ---->  +------------------------------+ 0xf0000000      --+
 *    KSTACKTOP        |     CPU0's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     |     CPU1's Kernel Stack      | RW/--  KSTKSIZE   |
 *                     | - - - - - - - - - - - - - - -|                 PTSIZE
 *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |
 *                     +------------------------------+                   |
 *                     :              .               :                   |
 *                     :              .               :                   |
 *    MMIOLIM ------>  +------------------------------+ 0xefc00000      --+
 *                     |       Memory-mapped I/O      | RW/--  PTSIZE
 * ULIM, MMIOBASE -->  +------------------------------+ 0xef800000
 *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE
 *    UVPT      ---->  +------------------------------+ 0xef400000
 *                     |          RO PAGES            | R-/R-  PTSIZE
 *    UPAGES    ---->  +------------------------------+ 0xef000000
 *                     |           RO ENVS            | R-/R-  PTSIZE
 * UTOP,UENVS ------>  +------------------------------+ 0xeec00000
 * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebff000
 *                     |       Empty Memory (*)       | --/--  PGSIZE
 *    USTACKTOP  --->  +------------------------------+ 0xeebfe000
 *                     |      Normal User Stack       | RW/RW  PGSIZE
 *                     +------------------------------+ 0xeebfd000
 *                     |                              |
 *                     |                              |
 *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                     .                              .
 *                     .                              .
 *                     .                              .
 *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|
 *                     |     Program Data & Heap      |
 *    UTEXT -------->  +------------------------------+ 0x00800000
 *    PFTEMP ------->  |       Empty Memory (*)       |        PTSIZE
 *                     |                              |
 *    UTEMP -------->  +------------------------------+ 0x00400000      --+
 *                     |       Empty Memory (*)       |                   |
 *                     | - - - - - - - - - - - - - - -|                   |
 *                     |  User STAB Data (optional)   |                 PTSIZE
 *    USTABDATA ---->  +------------------------------+ 0x00200000        |
 *                     |       Empty Memory (*)       |                   |
 *    0 ------------>  +------------------------------+                 --+
 *
 * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
 *     "Empty Memory" is normally unmapped, but user programs may map pages
 *     there if desired.  JOS user programs map pages temporarily at UTEMP.
 */
```

Jos为内核保留了256MB的虚拟空间，这样就可以理解，为什么在实验中要给操作系统设计一个高地址的地址空间，如果不这样做，用户环境的地址空间就不够了。

由于内核和用户进程只能访问各自的地址空间，所以我们必须在x86的页表中使用访问权限位来使用用户进程的代码只能访问用户地址空间，而访问不了内核地址空间，否则用户代码中的错误会覆盖内核中的数据，导致内核的崩溃。

用户地址空间的代码不能访问高于ULIM的地址空间，但是内核可以读写这部分空间。而内核和用户对于地址[UTOP, ULIM]有相同的访问权限，可以读取，但是不可以写入，这一个部分的地址空间通常被用于把一些只读的内核数据结构暴露给用户地址空间的代码。在UTOP之下的地址范围是给用户使用的，用户进程可以访问，修改这部分地址空间的内容。

## Exercise 5

继续晚上mem_init()函数，程序必须能通过check_kern_pgdir和check_page_installed_pgdir函数的检测。

```C

// Set up a two-level page table:
//    kern_pgdir is its linear (virtual) address of the root
//
// This function only sets up the kernel part of the address space
// (ie. addresses >= UTOP).  The user part of the address space
// will be set up later.
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
mem_init(void)
{
	uint32_t cr0;
	size_t n;

	// Find out how much memory the machine has (npages & npages_basemem).
	i386_detect_memory();

	// Remove this line when you're ready to test this function.
	// panic("mem_init: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address UVPT.
	// (For now, you don't have understand the greater purpose of the
	// following line.)

	// Permissions: kernel R, user R
	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;

	//////////////////////////////////////////////////////////////////////
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	// Your code goes here:
	pages = (struct PageInfo *)boot_alloc(npages*sizeof(struct PageInfo));
	memset(pages, 0, npages * sizeof(struct PageInfo));

	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region
	// or page_insert
	page_init();

	check_page_free_list(1);
	check_page_alloc();
	check_page();

	//////////////////////////////////////////////////////////////////////
	// Now we set up virtual memory

	//////////////////////////////////////////////////////////////////////
	// Map 'pages' read-only by the user at linear address UPAGES
	// Permissions:
	//    - the new image at UPAGES -- kernel R, user R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
	boot_map_region(kern_pgdir, UPAGES, ROUNDUP(npages* sizeof(struct PageInfo), PGSIZE), PADDR(pages), PTE_U);
	//////////////////////////////////////////////////////////////////////
	// Use the physical memory that 'bootstack' refers to as the kernel
	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
	// to be the kernel stack, but break this into two pieces:
	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:
    // 需要注意的一点就是，
	boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);

	//////////////////////////////////////////////////////////////////////
	// Map all of physical memory at KERNBASE.
	// Ie.  the VA range [KERNBASE, 2^32) should map to
	//      the PA range [0, 2^32 - KERNBASE)
	// We might not have 2^32 - KERNBASE bytes of physical memory, but
	// we just set up the mapping anyway.
	// Permissions: kernel RW, user NONE
	// Your code goes here:
	boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE, 0, PTE_W);
	// Check that the initial page directory has been set up correctly.
	check_kern_pgdir();

	// Switch from the minimal entry page directory to the full kern_pgdir
	// page table we just created.	Our instruction pointer should be
	// somewhere between KERNBASE and KERNBASE+4MB right now, which is
	// mapped the same way by both page tables.
	//
	// If the machine reboots at this point, you've probably set up your
	// kern_pgdir wrong.
	lcr3(PADDR(kern_pgdir));

	check_page_free_list(0);

	// entry.S set the really important flags in cr0 (including enabling
	// paging).  Here we configure the rest of the flags that we care about.
	cr0 = rcr0();
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
	cr0 &= ~(CR0_TS|CR0_EM);
	lcr0(cr0);

	// Some more checks, only possible after kern_pgdir is installed.
	check_page_installed_pgdir();
}

```

## Questions

### Q2

哪些地址对应哪些表项：

| entry | base virtual addres | point to(logically)                       |
| ----- | ------------------- | ----------------------------------------- |
| 1023  | 0xffc00000          | Page table for top 4MB of phys memory     |
| 961   | 0xf0400000          | Page table for [4,8) Mb of physics memory |
| 960   | 0xf0000000          | Page table for [0,4) Mb of physics memory |
| 959   | 0xefc00000          | bootstack                                 |
| 958   | 0xef800000          | Kern_pgdir                                |
| 957   | 0xef400000          | pages数组                                 |

等等，见上面的布局分布图。

### Q3

我们讲内核和用户的环境放在相同的地址上，为什么用户程序不能读取或者写入内核代码，我们使用了什么机制来保护内核的空间。

在JOS中是通过分页机制来实现，将页表中的对应flag置0即可。

### Q4

这个操作系统的最大内存是多少？

4MB空间Upages来房所有页的信息，每一个页的信息为8Byte，所以一共可以放512k个pageInfo，所以是512k个物理页，每个物理页面大小为4kb，所以总的物理内存占2GB。

### Q5

如果所有的物理内存页达到最大个数，那么管理这些内存所需要的额外空间需要多少。

pageinfo需要4MB，页目录表需要4kb，所以需要4MB+4kb.

### Q6

回顾entry.S文件中，当分页机制开启时，寄存器EIP的值仍旧是一个小的值。在哪个位置代码才开始运行在高于KERNBASE的虚拟地址空间中的？当程序位于开启分页之后到运行在KERNBASE之上这之间的时候，EIP的值是小的值，怎么保证可以把这个值转换为真实物理地址的？

jmp *%eax实现的跳转，重新设置EIP的值，把它设置为寄存器eax中的值，这个时候发生了跳转。