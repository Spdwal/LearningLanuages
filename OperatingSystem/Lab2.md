# Lab Requirements

做完所有的练习，并且完成起码一个challenge。

# Part 1: Physical Page Management

## Exercise 1

在kern/pmap.c中，完成如下代码：

```c
boot_alloc()
mem_init()
page_init()
page_alloc()
page_free()
```

```c
static void *
boot_alloc(uint32_t n)
{
    // 虚拟地址中下一块可用的内存
    // 它是一个静态变量，所以需要不断的更新。
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
    //  end 是链接器产生的一个魔法symbol，它指向了bss段的末尾。
    //  bss前面是data段，后面是空白。这个指针指向的空间，链接器没有放入任何kernel带代码或者全局变量。
    // 所以可以任意的使用。
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
    // 第一次调用这个函数的时候，他是静态初始化状态，为0，所以我们在此为其赋值。
	if (!nextfree) {
		extern char end[];
        // 向上对齐最近的PGSIZE。
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
    // 分配空间，用PGSIZE作为对齐。
	char * new_next_free = ROUNDUP((char *)n + nextfree, PGSIZE);
    // 如果new_next_free < nextfree) 分配失败。
    if(new_next_free < nextfree){
        panic("Boot alloc bad.\n");
    }
    //超过地址空间。
    if(new_next_free >= 0x400000){
        panic("The boot alloc extendx 4MB.\n");
    }
    
    // 保存需要返回的值
    void* ret_adress = (void*) nextfree;
    // 更新值。
    nextfree = new_next_free;
	return ret_adress;
}
```

```c
/*******************************************************************************
	struct PageInfo {
		// Next page on the free list.
		struct PageInfo *pp_link;

		// pp_ref is the count of pointers (usually in page table entries)
		// to this page, for pages allocated using page_alloc.
		// Pages allocated at boot time using pmap.c's
		// boot_alloc do not have valid reference count fields.

		uint16_t pp_ref;
	};
*******************************************************************************/

// --------------------------------------------------------------
// Tracking of physical pages.
// The 'pages' array has one 'struct PageInfo' entry per physical page.
// Pages are reference counted, and free pages are kept on a linked list.
// --------------------------------------------------------------

//
// Initialize page structure and memory free list.
// After this is done, NEVER use boot_alloc again.  ONLY use the page
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
	// The example code here marks all physical pages as free.
	// However this is not truly the case.  What memory is free?
	//  1) Mark physical page 0 as in use.
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free.
    //      [1, npages_basemem]这一段的内存是free的。
    //     紧跟在后的是[IOPHTSMEM, EXTPHTSMEM]这一段内存，他们也不可以被alloc
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated.
	//  4) Then extended memory [EXTPHYSMEM, ...).
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
	size_t i;
    // 第一个page是被使用的；
    pages[0].pp_ref = 1;
	for (i = 1; i < npages_basemem; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
        // 因为是空闲页，所以将它送入pages_free_list链表。
        // 头插法进入链表
		page_free_list = &pages[i];
	}
    // 返回可分配空间的第一个位置，计算出的它物理地址，然后除以PGSIZE,得出extmem区域中已经被占用的页数。
 	int num_alloc = ((uint_32t)boot_alloc(0) - KERNBASE) / PGSIZE;
    // iohole区域被占用的页数。
    int iohole = (EXTPHYSMEM - IOPHYMEM) / PGSIZE;
    // iohole 不能被alloc
    for(; i < npages_basemem + num_alloc + iohole; ++i){
        pages[i].pp_ref = 1;
    }
    for(i = npages_basemem + num_alloc + iohole; i < npages; ++i){
        pages[i].pp_ref = 0;
        pages[i].pp_link = page_free_list;
        page_free_list = &pages[i];
    }
}
```

```c
// Allocates a physical page.  If (alloc_flags & ALLOC_ZERO), fills the entire
// returned physical page with '\0' bytes.  Does NOT increment the reference
// count of the page - the caller must do these if necessary (either explicitly
// or via page_insert).
//
// Be sure to set the pp_link field of the allocated page to NULL so
// page_free can check for double-free bugs.
//
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
	// Fill this function in
	// 返回值。
	struct Pageinfo* result;
	//  如果没有free空间了。打印信息，返回NULL
	if(page_free_list == NULL){
		cprintf("No Page Free.\n");
		return NULL;
	}
	// 取链表中第一个为result
	result = page_free_list;
    // 将头从链表中弹出。
	page_free_list = result->pp_link;
    // 将头彻底语链表分离。
	result->pp_link = NULL;
	
    // 按照注释所说，如果传入了一个ALLOC_ZERO flag，那么将整个页初始化为0
	if(alloc_flags & ALLOC_ZERO){
		memset(page2kva(result), 0, PGSIZE);
	}
	return result;
}

```

```c
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if(pp->pp_ref != 0){
		panic("Can't Free: the page is reference by someone.\n");
	}
	if(pp->pp_link != NULL){
		panic("Can;t Free. the page is in the page free list.\n");
	}
	// 将pp添加在page_free_List的头部
	pp->pp_link = page_free_list;
	page_free_list = pp;
}

```

# Part 2: Virtual Memory

## Exercise 2

阅读Intel 80386 Reference Manual的第五章和第六章，重点是页转换和page-based protection。

文档写的是真的晦涩，难看的要命。

在x86中，一个虚拟地址是有一个段选择子和一个段offset组成的。一个虚拟地址转换成物理地址需要经过段转换和页转换。

在boot/boot.s中，我们吧GDT加载进了内存，并且通过将段地址设置为0~0xffffffff来关闭了段转换，所以现在selector就没有用了，线性地址就等于虚拟地址的偏移。在Lab1中，我们加载了一个简单的页表，然后内核可以运行在0xf0100000中，这个页表只映射了4MB的内存。我们将会使它映射虚拟地址0xf0000000的头256MB，并且映射其他的虚拟地址空间。

## Exercise 3

